"use strict";var _interopRequireWildcard=require("@babel/runtime-corejs2/helpers/interopRequireWildcard"),_interopRequireDefault=require("@babel/runtime-corejs2/helpers/interopRequireDefault"),_Object$defineProperty=require("@babel/runtime-corejs2/core-js/object/define-property");_Object$defineProperty(exports,"__esModule",{value:!0}),exports.default=void 0;var _promise=_interopRequireDefault(require("@babel/runtime-corejs2/core-js/promise")),_path=_interopRequireDefault(require("path")),_cliSharedUtils=require("@vivo-minigame/cli-shared-utils"),paths=_interopRequireWildcard(require("../lib/paths")),_constanst=require("../lib/constanst"),_readdir=_interopRequireDefault(require("../lib/readdir")),_rpk=_interopRequireDefault(require("../lib/rpk")),_rpkPlugin=_interopRequireDefault(require("../lib/rpkPlugin"));// 签名文件
const signFiles={debug:{privatekey:paths.DEBUG_PRIVATE_KEY,certificate:paths.DEBUG_CERTIFICATE},release:{privatekey:paths.RELEASE_PRIVATE_KEY,certificate:paths.RELEASE_CERTIFICATE}// 在build里面获取 除去插件包的全部文件
};function getLeftFiles(a,b){const c=[];for(let d=a.length-1;0<=d;d--){const e=a[d],f=_path.default.extname(b);""===f&&0>e.indexOf(b)&&c.push(a[d])}return c}// 打插件包
function pluginRpk(a,b,c){// 获取插件包文件列表和除去插件包的文件列表 和全部文件列表（打出兼容包）
const d=getLeftFiles(a,b),e=(0,_rpkPlugin.default)(`${b}.rpk`,b,paths.TEMP),f=(0,_rpk.default)(`${_constanst.MAIN}${_constanst.RPK}`,d,paths.BUILD,paths.TEMP,c);// 有插件包
return[e,f]}class ZipWebpackPlugin{constructor(a){this.options=a}apply(a){const{release:b,packageName:c,singlePackage:d,subpackages:e,pluginPath:f}=this.options;a.hooks.afterEmit.tapPromise("ZipWebpackPlugin",()=>{// 编译完成开始打包，打包前先校验签名文件是否存在
const a=signFiles[b?"release":"debug"],g=b?_constanst.RPK_SIGNED:_constanst.RPK;// debug包的后缀 .rpk  release包的后缀 .signed.rpk
if(!_cliSharedUtils.fs.existsSync(a.privatekey))throw new Error(`${_constanst.LOG_TITLE}缺少私钥文件, 打包失败: ${a.privatekey}`);if(!_cliSharedUtils.fs.existsSync(a.certificate))throw new Error(`${_constanst.LOG_TITLE}缺少证书文件, 打包失败: ${a.certificate}`);return new _promise.default(b=>{(0,_cliSharedUtils.info)(`${_constanst.LOG_TITLE}${d?"\u539F\u6574\u5305\u7F16\u8BD1\u5B8C\u6210\uFF0C\u5F00\u59CB\u751F\u6210\u539F\u6574\u5305":"\u5206\u5305\u7F16\u8BD1\u5B8C\u6210\uFF0C\u5F00\u59CB\u751F\u6210\u5206\u5305"}`);// 遍历出build目录所有文件
const h=(0,_readdir.default)(paths.BUILD);// 如果是打原整包
if(!d){// 如果存在分包，那么就打出各个分包，并和原整包一起再打一个rpk，到dist目录
const d=[];// 根据分包配置，找到各个包对应的资源。执行如下操作后，files中剩下的即为主包的资源
e.forEach(({name:a,root:b})=>{const c=[];for(let d=h.length-1;0<=d;d--){const a=h[d],e=_path.default.extname(b);""===e&&0===a.indexOf(b)?c.push(h.splice(d,1)[0]):""!==e&&(a===b||`${b}.map`===a)&&c.push(h.splice(d,1)[0])}d.push({name:a,matchFiles:c})});// 打各个分包
const i=d.map(({name:b,matchFiles:c})=>(0,_rpk.default)(`${b}${_constanst.RPK}`,c,paths.BUILD,paths.TEMP,a));let j;// 分包都打好后，连原整包一起打一个整包
j=f?pluginRpk(h,f,a):[(0,_rpk.default)(`${_constanst.MAIN}${_constanst.RPK}`,h,paths.BUILD,paths.TEMP,a)],_promise.default.all([...i,...j]).then(function(){(0,_rpk.default)(`${c}${g}`,(0,_readdir.default)(paths.TEMP),paths.TEMP,paths.DIST,a).then(()=>{b()})})}else// 插件true 分包false
if(f&&0===e.length){// 原整包的打包
const d=[(0,_rpk.default)(`${c}${_constanst.RPK}`,h,paths.BUILD,paths.TEMP,a)],e=pluginRpk(h,f,a);_promise.default.all([...e,...d]).then(function(){(0,_cliSharedUtils.info)(`${_constanst.LOG_TITLE}插件包打包完成，开始生成总包...`),(0,_rpk.default)(`${c}${g}`,(0,_readdir.default)(paths.TEMP),paths.TEMP,paths.DIST,a).then(()=>{b()})})}else// 插件false 分包false
// 打原整包到temp目录 有插件包的也走这个逻辑，因为需要打个兼容的包
(0,_rpk.default)(`${c}${_constanst.RPK}`,h,paths.BUILD,paths.TEMP,a).then(b)})})}}var _default=ZipWebpackPlugin;exports.default=_default;