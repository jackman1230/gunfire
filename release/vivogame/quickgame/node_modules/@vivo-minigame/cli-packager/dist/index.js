'use strict';var _interopRequireWildcard=require("@babel/runtime-corejs2/helpers/interopRequireWildcard"),_interopRequireDefault=require("@babel/runtime-corejs2/helpers/interopRequireDefault"),_Object$defineProperty=require("@babel/runtime-corejs2/core-js/object/define-property");_Object$defineProperty(exports,"__esModule",{value:!0}),exports.zip=exports.release=exports.watch=exports.default=void 0;var _keys=_interopRequireDefault(require("@babel/runtime-corejs2/core-js/object/keys")),_path=_interopRequireDefault(require("path")),_webpack=_interopRequireDefault(require("webpack")),_cliSharedUtils=require("@vivo-minigame/cli-shared-utils"),_cliServer=require("@vivo-minigame/cli-server"),_process=_interopRequireWildcard(require("./config/process")),paths=_interopRequireWildcard(require("./lib/paths")),_manifest=require("./lib/manifest"),_constanst=require("./lib/constanst"),_subpackage=require("./lib/subpackage"),_rpk=_interopRequireDefault(require("./lib/rpk")),_readdir=_interopRequireDefault(require("./lib/readdir")),_writeMD=_interopRequireDefault(require("./lib/writeMD5"));const watch=async a=>run({...a,watch:!0});exports.watch=watch;const release=async a=>run({...a,release:!0});exports.release=release;const run=async({release:a=!1,watch:b=!1,inject:c=!0})=>{(0,_manifest.check)(),_cliSharedUtils.fs.removeSync(paths.BUILD),_cliSharedUtils.fs.removeSync(paths.DIST),_cliSharedUtils.fs.removeSync(paths.TEMP);// 读取manifest配置
const d=(0,_manifest.get)();// 是否配置插件包的判断
// 对manifest的插件配置个数进行校验
try{if(d.plugins){const a=(0,_keys.default)(d.plugins).length;if(1<a)return void(0,_cliSharedUtils.error)("\u8BF7\u68C0\u67E5manifest.json\u7684\u914D\u7F6E\uFF0C\u63D2\u4EF6\u53EA\u652F\u6301\u914D\u7F6E\u4E00\u4E2A\uFF0C\u5373plugins\u53EA\u80FD\u6709\u4E00\u4E2A\u5C5E\u6027")}}catch(a){(0,_cliSharedUtils.error)(a)}// 取pluginPath，并判断配置的合法性
// 对插件包里面的文件plugin.json判断
let e;try{const a=d.plugins?d.plugins["cocos-library"]||d.plugins["laya-library"]||d.plugins["egret-library"]:"";// 校验version不超过32字符
if(e=a.path,a&&32<a.version.length)return void(0,_cliSharedUtils.error)("\u8BF7\u68C0\u67E5manifest.json\u7684\u914D\u7F6E\uFF0Cplugins\u7684\u63D2\u4EF6\u7684version\u5B57\u6BB5\u7684\u503C\u5B57\u7B26\u4E0D\u80FD\u8D85\u8FC732\u4E2A\uFF0C\u8BF7\u4FEE\u6539\u540E\u518D\u5C1D\u8BD5");// 校验pluginPath的合法性
if(d.plugins&&0>["cocos-library","laya-library","egret-library"].indexOf(e))return void(0,_cliSharedUtils.error)("\u8BF7\u68C0\u67E5manifest.json\u7684\u914D\u7F6E\uFF0Cplugins\u7684\u63D2\u4EF6\u7684path\u5C5E\u6027\u503C\u9700\u8981\u8DDF\u63D2\u4EF6\u540D\u79F0\u4E00\u6837\uFF0C\u4E3Acocos-library | laya-library | egret-library \u8FD9\u4E09\u4E2A\u4E2D\u7684\u5176\u4E2D\u4E00\u4E2A");// 对插件包里面的文件做判断
if(d.plugins&&!_cliSharedUtils.fs.pathExistsSync(_path.default.join(_cliSharedUtils.projectPath,e,"/plugin.json")))return void(0,_cliSharedUtils.error)("\u8BF7\u68C0\u67E5\u63D2\u4EF6\u5305\u662F\u5426\u5B58\u5728\uFF0C\u8BF7\u68C0\u67E5\u91CC\u9762\u7684\u6587\u4EF6plugin.json\u662F\u5426\u7F3A\u5931")}catch(a){return void("Cannot read property 'path' of undefined"===a.message&&(0,_cliSharedUtils.error)("\u8BF7\u68C0\u67E5manifest.json\u7684\u914D\u7F6E\uFF0Cplugins\u7684\u5C5E\u6027\u503C\u53EA\u80FD\u4E3Acocos-library | laya-library | egret-library \u8FD9\u4E09\u4E2A\u4E2D\u7684\u5176\u4E2D\u4E00\u4E2A"))}// 写入MD5值
e&&(0,_writeMD.default)(e);// 过滤出合法的分包配置
const f=(0,_subpackage.filter)(d.subpackages),{entry:g,externals:h,resConfig:i}=(0,_subpackage.toConfigs)(f),j=d.package||"Bundle",k=(0,_process.default)({release:a,entry:g,resConfig:i,pluginPath:e}),l=(0,_webpack.default)((0,_process.singleConfig)(k,{release:a,packageName:j,externals:h,inject:c,pluginPath:e,subpackages:f})),m=(b,c)=>{if(!(0,_process.checkError)(b,c))// 原整包打包完成后，判断是否存在分包配置，如果有就编译分包，如果没有，拷贝原整包作为最终的输出包
if((0,_cliSharedUtils.info)(`${_constanst.LOG_TITLE}原整包打包完成！ 耗时: ${(c.endTime-c.startTime)/1e3}s`),f.length)(0,_cliSharedUtils.info)(`${_constanst.LOG_TITLE}开始编译分包...`),(0,_webpack.default)((0,_process.multiConfig)(k,{release:a,packageName:j,externals:h,subpackages:f,pluginPath:e}),(a,b)=>{(0,_process.checkError)(a,b)||((0,_cliSharedUtils.info)(`${_constanst.LOG_TITLE}总包打包完成！ 耗时: ${(b.endTime-b.startTime)/1e3}s`),n())});else// 不分包不带插件包的 才走这个逻辑
// 不分包的带插件包的打包已经在webpack插件里面做了
if(!e){const b=_path.default.join(paths.TEMP,`${j}${_constanst.RPK}`),c=_path.default.join(paths.DIST,`${j}${a?_constanst.RPK_SIGNED:_constanst.RPK}`);_cliSharedUtils.fs.copy(b,c).then(n).catch(a=>{(0,_cliSharedUtils.error)(a)})}else n()},n=()=>{// 打包完成后，删除临时目录
// 通知调试器更新包
_cliSharedUtils.fs.removeSync(paths.TEMP),(0,_cliSharedUtils.done)(`${_constanst.LOG_TITLE}压缩包已生成:${paths.DIST}`),b&&((0,_cliSharedUtils.log)(),(0,_cliSharedUtils.info)(`${_constanst.LOG_TITLE}开始监听文件变动，变动后自动重新构建...`)),(0,_cliServer.notifyUpdate)()};// 将分包配置转化为对应的webpack的打包入口
// 将分包配置转化为对应的externals用于打出兼容的原整包
(0,_cliSharedUtils.info)(`${_constanst.LOG_TITLE}开始编译原整包...`),b?l.watch({aggregateTimeout:1e3,ignored:/node_modules/},m):l.run(m)},zip=({name:a,pathFrom:b,pathTo:c,signFile:d})=>{const e=(0,_readdir.default)(b);return(0,_rpk.default)(a,e,b,c,d)};exports.zip=zip;var _default=run;exports.default=_default;